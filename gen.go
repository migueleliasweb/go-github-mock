package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"regexp"
	"strings"

	"github.com/PuerkitoBio/goquery"
)

//go:generate go run gen.go

const BASE_URL = "https://docs.github.com"

const GITHUB_REST_API_URL = "https://docs.github.com/en/rest"

const OUTPUT_FILE_HEADER = `package mock

// Code generated by main.go; DO NOT EDIT.

`
const OUTPUT_FILEPATH = "src/mock/endpointpattern.go"

type ScrapeResult struct {
	HTTPMethod      string
	EndpointPattern string
}

func getGoQueryDocumentFromUrl(urlToScrape string) (*goquery.Document, error) {
	res, err := http.Get(urlToScrape)
	if err != nil {
		log.Fatal(err)
	}
	defer res.Body.Close()
	if res.StatusCode != 200 {
		log.Fatalf("status code error: %d %s", res.StatusCode, res.Status)
	}

	doc, err := goquery.NewDocumentFromReader(res.Body)
	if err != nil {
		log.Fatal(err)
	}

	return doc, err
}

func scrapeReferenceTab() []string {
	doc, err := getGoQueryDocumentFromUrl(GITHUB_REST_API_URL)

	if err != nil {
		log.Fatal(err)
	}

	restEndpoints := []string{}

	doc.Find("#__next > div > div > nav > ul > li:nth-child(3) > ul > li:nth-child(2) > details > ul > li > a").
		Each(func(i int, s *goquery.Selection) {
			if v, ok := s.Attr("href"); ok {
				restEndpoints = append(restEndpoints, fmt.Sprintf("%s%s", BASE_URL, v))
			}
		})

	return restEndpoints
}

func scrapeApiReference(url string) <-chan ScrapeResult {
	scrapedEndpoints := make(chan ScrapeResult)

	go func() {
		doc, err := getGoQueryDocumentFromUrl(url)
		if err != nil {
			log.Fatal(err)
		}

		doc.Find("#article-contents > div > pre > code").Each(
			func(i int, s *goquery.Selection) {
				combinedInnerTextSplit := strings.Split(
					s.Text(),
					" ",
				)

				scrapedEndpoints <- ScrapeResult{
					HTTPMethod:      combinedInnerTextSplit[0],
					EndpointPattern: combinedInnerTextSplit[1],
				}
			},
		)

		close(scrapedEndpoints)
	}()

	return scrapedEndpoints
}

// formatToGolangVarName generated the proper golang variable name
// given a endpoint format from the API
//
// Input:
//
//	sr.HTTPMethod = "get"
//
//	sr.EndpointPattern = "/repos/{owner}/{repo}/actions/artifacts"
//	sr.EndpointPattern = "/repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
//	sr.EndpointPattern = "/orgs/{org}/actions/permissions/selected-actions"
//	sr.EndpointPattern = "/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
func formatToGolangVarName(sr ScrapeResult) string {
	pattern := strings.ReplaceAll(sr.EndpointPattern, "-", "/")

	epSplit := strings.Split(
		pattern,
		"/",
	)

	result := ""

	for _, part := range epSplit {
		if len(part) < 1 || string(part[0]) == "{" {
			continue
		}

		splitPart := strings.Split(part, "_")

		for _, p := range splitPart {
			result = result + strings.Title(p)
		}
	}

	regex := regexp.MustCompile(`[a-z]+`)

	for _, part := range epSplit {
		if len(part) < 1 {
			continue
		}

		if string(part[0]) == "{" {
			result = result + "By" +
				strings.Title(regex.FindString(part))
		}
	}

	return strings.Title(sr.HTTPMethod) + result
}

func formatToGolangVarNameAndValue(sr ScrapeResult) string {
	return fmt.Sprintf(
		`var %s EndpointPattern = EndpointPattern{
	Pattern: "%s",
	Method:  "%s",
}
`,
		formatToGolangVarName(sr),
		sr.EndpointPattern,
		strings.ToUpper(sr.HTTPMethod),
	) + "\n"
}

func main() {
	referenceUrlsToScrape := scrapeReferenceTab()

	buf := bytes.NewBuffer([]byte(OUTPUT_FILE_HEADER))

	for _, url := range referenceUrlsToScrape {
		res := scrapeApiReference(url)

		for r := range res {
			buf.WriteString(formatToGolangVarNameAndValue(r))
		}
	}

	ioutil.WriteFile(
		OUTPUT_FILEPATH,
		buf.Bytes(),
		0755,
	)
}
